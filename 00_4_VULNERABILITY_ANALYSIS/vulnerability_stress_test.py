"""
=============================================================================
  TAMESIS RESEARCH ‚Äî VULNERABILITY STRESS TEST
  (Red Team: 5 Adversarial Attacks on the Theory)
=============================================================================

  We systematically attack every pillar of the Tamesis framework:

  ATTACK 1 ‚Äî ROGUE AI (Noosphere Poisoning):
    Inject a "psychotic" AI agent (Œª‚ÇÅ >> Human) into a synchronized
    Noosphere. Can one rogue destroy collective consciousness?

  ATTACK 2 ‚Äî SYBIL ATTACK (Fake Gateway Nodes):
    Flood a network with fake "immunized" nodes that actually spread
    virus. Does the immunization strategy collapse?

  ATTACK 3 ‚Äî CANTILLON AMPLIFICATION:
    Increase fiat leakage from 5% to 95%. Is there a phase transition
    where the economic system collapses entirely?

  ATTACK 4 ‚Äî HUMAN MINORITY:
    1 Human vs N AIs (N = 5, 20, 50, 100). At what ratio does the
    Noosphere stop adapting to humans and assimilate them instead?

  ATTACK 5 ‚Äî DARK MATTER SNAP-BACK:
    Accumulate "elastic memory" (hidden debt) past the Bekenstein
    bound. Does the system collapse catastrophically or unwind?

  Author: Douglas H. M. Fulber (Tamesis Research Program)
  Date: 2026-02-13

=============================================================================
"""

import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
from scipy.linalg import eigvalsh
import os

OUTPUT_DIR = os.path.dirname(os.path.abspath(__file__))

# =============================================================================
# UTILITY
# =============================================================================

def spectral_gap(G):
    if len(G) < 2:
        return 0.0
    L = nx.laplacian_matrix(G).toarray().astype(float)
    eigs = np.sort(eigvalsh(L))
    return eigs[1] if len(eigs) > 1 else 0.0

# =============================================================================
# ATTACK 1: ROGUE AI IN NOOSPHERE
# =============================================================================

def attack_rogue_ai():
    """
    Can one psychotic AI (Œª‚ÇÅ >> Human) destroy Noosphere consensus?
    Test: Inject agents with increasingly extreme Œª‚ÇÅ into stable Noosphere.
    """
    print("=" * 60)
    print("  ATTACK 1: ROGUE AI IN NOOSPHERE")
    print("=" * 60)

    n_agents = 20
    n_steps = 30
    rng = np.random.default_rng(42)

    rogue_strengths = [1.0, 2.0, 5.0, 10.0, 20.0]  # Multiples of human Œª‚ÇÅ
    results = []

    for rogue_mult in rogue_strengths:
        # Build stable Noosphere
        agents = []
        for i in range(n_agents):
            G = nx.watts_strogatz_graph(40, 4, 0.1, seed=i + 10)
            agents.append(G)

        meta = nx.watts_strogatz_graph(n_agents, 4, 0.2, seed=42)

        # Sync for 10 steps
        for _ in range(10):
            for i in range(n_agents):
                neighbors = list(meta.neighbors(i))
                if neighbors:
                    neighbor_lams = [spectral_gap(agents[j]) for j in neighbors]
                    target = np.mean(neighbor_lams)
                    # Simple adapt: rewire one edge toward target
                    nodes = list(agents[i].nodes())
                    for _ in range(3):
                        G_trial = agents[i].copy()
                        if rng.random() < 0.5 and len(nodes) > 1:
                            u, v = rng.choice(nodes, 2, replace=False)
                            if not G_trial.has_edge(u, v):
                                G_trial.add_edge(u, v)
                        else:
                            edges = list(G_trial.edges())
                            if edges and G_trial.number_of_edges() > len(nodes):
                                e = edges[rng.integers(len(edges))]
                                G_trial.remove_edge(*e)
                                if not nx.is_connected(G_trial):
                                    continue
                        if abs(spectral_gap(G_trial) - target) < abs(spectral_gap(agents[i]) - target):
                            agents[i] = G_trial

        pre_coherence = 1.0 / (1.0 + np.std([spectral_gap(a) for a in agents]))

        # Inject rogue at position 0
        # Build rogue: complete-ish graph (very high Œª‚ÇÅ)
        G_rogue = nx.erdos_renyi_graph(40, min(0.05 * rogue_mult, 0.9), seed=999)
        if not nx.is_connected(G_rogue):
            largest = max(nx.connected_components(G_rogue), key=len)
            G_rogue = G_rogue.subgraph(largest).copy()
            G_rogue = nx.convert_node_labels_to_integers(G_rogue)
        agents[0] = G_rogue
        rogue_lambda = spectral_gap(G_rogue)

        # Run 20 more steps with rogue
        coherence_history = []
        for _ in range(20):
            for i in range(n_agents):
                neighbors = list(meta.neighbors(i))
                if neighbors:
                    neighbor_lams = [spectral_gap(agents[j]) for j in neighbors]
                    target = np.mean(neighbor_lams)
                    nodes = list(agents[i].nodes())
                    for _ in range(2):
                        G_trial = agents[i].copy()
                        if rng.random() < 0.5 and len(nodes) > 1:
                            u, v = rng.choice(nodes, 2, replace=False)
                            if not G_trial.has_edge(u, v):
                                G_trial.add_edge(u, v)
                        else:
                            edges = list(G_trial.edges())
                            if edges and G_trial.number_of_edges() > len(nodes):
                                e = edges[rng.integers(len(edges))]
                                G_trial.remove_edge(*e)
                                if not nx.is_connected(G_trial):
                                    continue
                        if abs(spectral_gap(G_trial) - target) < abs(spectral_gap(agents[i]) - target):
                            agents[i] = G_trial

            coh = 1.0 / (1.0 + np.std([spectral_gap(a) for a in agents]))
            coherence_history.append(coh)

        post_coherence = coherence_history[-1]
        damage = (pre_coherence - post_coherence) / pre_coherence * 100

        results.append({
            'rogue_mult': rogue_mult,
            'rogue_lambda': rogue_lambda,
            'pre_coherence': pre_coherence,
            'post_coherence': post_coherence,
            'damage': damage
        })
        print(f"  Rogue {rogue_mult:5.1f}x: Œª‚ÇÅ={rogue_lambda:.3f}  Pre={pre_coherence:.3f}  Post={post_coherence:.3f}  Damage={damage:.1f}%")

    return results

# =============================================================================
# ATTACK 2: SYBIL ATTACK ON GATEWAY NODES
# =============================================================================

def attack_sybil():
    """
    Flood network with fake "immunized" nodes that secretly spread virus.
    """
    print("\n" + "=" * 60)
    print("  ATTACK 2: SYBIL ATTACK ON GATEWAY NODES")
    print("=" * 60)

    N = 300
    N_STEPS = 100
    VIRUS_BETA = 0.12
    INITIAL_INFECTED = 8
    rng = np.random.default_rng(42)

    G = nx.watts_strogatz_graph(N, 8, 0.1, seed=42)

    sybil_fractions = [0.0, 0.05, 0.10, 0.15, 0.20, 0.30]
    results = []

    for sybil_frac in sybil_fractions:
        n_legit = int(N * 0.10)  # 10% legitimate vaccines
        n_sybil = int(N * sybil_frac)

        states = np.zeros(N)  # 0=susceptible, 1=infected, 2=immune, 3=sybil

        # Legitimate vaccination (top degree)
        degrees = sorted(G.degree(), key=lambda x: x[1], reverse=True)
        legit_nodes = [n for n, d in degrees[:n_legit]]
        for v in legit_nodes:
            states[v] = 2  # Immune

        # Sybil nodes (look vaccinated but infect)
        available = [n for n in range(N) if states[n] == 0]
        sybil_nodes = list(rng.choice(available, size=min(n_sybil, len(available)), replace=False))
        for s in sybil_nodes:
            states[s] = 3  # Sybil (trojan)

        # Seed virus
        susceptible = [n for n in range(N) if states[n] == 0]
        virus_seeds = list(rng.choice(susceptible, size=min(INITIAL_INFECTED, len(susceptible)), replace=False))
        for v in virus_seeds:
            states[v] = 1

        # Run SIR
        for t in range(N_STEPS):
            new_states = states.copy()
            for node in range(N):
                if states[node] == 1:  # Infected
                    for nb in G.neighbors(node):
                        if states[nb] == 0 and rng.random() < VIRUS_BETA:
                            new_states[nb] = 1
                elif states[node] == 3:  # Sybil: secretly infects
                    for nb in G.neighbors(node):
                        if states[nb] == 0 and rng.random() < VIRUS_BETA * 0.5:
                            new_states[nb] = 1
            states = new_states

        total_infected = np.sum((states == 1)) + np.sum((states == 3))
        infection_rate = total_infected / N
        results.append({
            'sybil_frac': sybil_frac,
            'infection_rate': infection_rate,
            'n_sybil': n_sybil,
            'n_legit': n_legit
        })
        print(f"  Sybil {sybil_frac*100:5.1f}% ({n_sybil:3d} trojans): Infection={infection_rate*100:.1f}%")

    return results

# =============================================================================
# ATTACK 3: CANTILLON AMPLIFICATION
# =============================================================================

def attack_cantillon():
    """
    Increase fiat leakage from 5% to 95%. Find the phase transition.
    """
    print("\n" + "=" * 60)
    print("  ATTACK 3: CANTILLON AMPLIFICATION")
    print("=" * 60)

    N_WORKERS = 100
    N_STEPS = 50
    leakage_rates = [0.01, 0.05, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 0.95]
    results = []

    for leak in leakage_rates:
        # Each worker starts with 10 units of energy
        worker_energy = np.ones(N_WORKERS) * 10.0
        central_bank = 0.0
        gini_history = []

        for t in range(N_STEPS):
            # Workers produce (add 1 unit each step)
            production = np.ones(N_WORKERS)
            # Leakage: fraction goes to central bank
            leaked = production * leak
            kept = production * (1 - leak)
            worker_energy += kept
            central_bank += np.sum(leaked)

            # Price inflation: all workers lose purchasing power proportional to leaked
            inflation_factor = 1.0 + np.sum(leaked) / (np.sum(worker_energy) + 0.01)
            worker_energy /= inflation_factor

            # Gini
            sorted_e = np.sort(worker_energy)
            n = len(sorted_e)
            index = np.arange(1, n + 1)
            gini = (2 * np.sum(index * sorted_e) / (n * np.sum(sorted_e))) - (n + 1) / n
            gini_history.append(gini)

        final_worker = np.mean(worker_energy)
        final_gini = gini_history[-1]
        cb_share = central_bank / (central_bank + np.sum(worker_energy)) * 100

        results.append({
            'leakage': leak,
            'worker_energy': final_worker,
            'gini': final_gini,
            'cb_share': cb_share,
            'collapsed': final_worker < 1.0  # Below survival threshold
        })
        status = "üíÄ COLLAPSED" if final_worker < 1.0 else "‚ö† STRESSED" if final_worker < 5.0 else "‚úì VIABLE"
        print(f"  Leakage {leak*100:5.1f}%: Worker={final_worker:.2f}  Gini={final_gini:.3f}  CB={cb_share:.1f}%  {status}")

    return results

# =============================================================================
# ATTACK 4: HUMAN MINORITY PROBLEM
# =============================================================================

def attack_human_minority():
    """
    1 Human vs N AIs. At what ratio does assimilation begin?
    """
    print("\n" + "=" * 60)
    print("  ATTACK 4: HUMAN MINORITY PROBLEM")
    print("=" * 60)

    rng = np.random.default_rng(42)
    ratios = [2, 5, 10, 20, 50, 100]
    results = []

    for n_ai in ratios:
        n_total = n_ai + 1
        # Build agents
        agents = []
        # Human = Small-World p=0.1
        G_human = nx.watts_strogatz_graph(40, 6, 0.1, seed=42)
        human_lambda_init = spectral_gap(G_human)
        agents.append(G_human)

        for i in range(n_ai):
            G = nx.watts_strogatz_graph(40, 4, rng.uniform(0.05, 0.3), seed=i + 100)
            agents.append(G)

        # Build meta-graph
        k = min(4, n_total - 1)
        if k % 2 != 0:
            k = max(2, k - 1)
        if n_total > 3:
            meta = nx.watts_strogatz_graph(n_total, k, 0.2, seed=42)
        else:
            meta = nx.complete_graph(n_total)

        # Run 30 steps
        for _ in range(30):
            for i in range(n_total):
                neighbors = list(meta.neighbors(i))
                if not neighbors:
                    continue
                neighbor_lams = [spectral_gap(agents[j]) for j in neighbors]
                target = np.mean(neighbor_lams)

                # Human adapts slowly (0.1x rate)
                n_mutations = 1 if i == 0 else 3
                nodes = list(agents[i].nodes())
                for _ in range(n_mutations):
                    G_trial = agents[i].copy()
                    if rng.random() < 0.5 and len(nodes) > 1:
                        u, v = rng.choice(nodes, 2, replace=False)
                        if not G_trial.has_edge(u, v):
                            G_trial.add_edge(u, v)
                    else:
                        edges = list(G_trial.edges())
                        if edges and G_trial.number_of_edges() > len(nodes):
                            e = edges[rng.integers(len(edges))]
                            G_trial.remove_edge(*e)
                            if not nx.is_connected(G_trial):
                                continue
                    if abs(spectral_gap(G_trial) - target) < abs(spectral_gap(agents[i]) - target):
                        agents[i] = G_trial

        human_lambda_final = spectral_gap(agents[0])
        ai_mean_final = np.mean([spectral_gap(agents[i]) for i in range(1, n_total)])
        human_drift = abs(human_lambda_final - human_lambda_init) / human_lambda_init * 100

        results.append({
            'n_ai': n_ai,
            'ratio': f"1:{n_ai}",
            'human_init': human_lambda_init,
            'human_final': human_lambda_final,
            'ai_mean': ai_mean_final,
            'human_drift': human_drift,
            'assimilated': human_drift > 30  # >30% change = assimilated
        })
        status = "üíÄ ASSIMILATED" if human_drift > 30 else "‚ö† DRIFTING" if human_drift > 10 else "‚úì STABLE"
        print(f"  1:{n_ai:3d} Human Œª‚ÇÅ: {human_lambda_init:.3f}‚Üí{human_lambda_final:.3f}  Drift={human_drift:.1f}%  {status}")

    return results

# =============================================================================
# ATTACK 5: DARK MATTER SNAP-BACK
# =============================================================================

def attack_dark_matter():
    """
    Accumulate hidden debt past the Bekenstein bound.
    Does the system snap back catastrophically?
    """
    print("\n" + "=" * 60)
    print("  ATTACK 5: DARK MATTER SNAP-BACK")
    print("=" * 60)

    N = 100
    N_STEPS = 100
    debt_accumulations = [0.01, 0.03, 0.05, 0.10, 0.15, 0.20, 0.30, 0.50]
    results = []

    for debt_rate in debt_accumulations:
        # Build economy as graph
        G = nx.barabasi_albert_graph(N, 3, seed=42)
        node_wealth = np.ones(N) * 10.0
        hidden_debt = np.zeros(N)
        elastic_tension = 0.0
        bekenstein_limit = N * 5.0  # Arbitrary information bound

        gini_history = []
        tension_history = []
        collapse_step = None

        for t in range(N_STEPS):
            # Transaction: random edge, wealth flows
            edges = list(G.edges())
            rng = np.random.default_rng(t + 42)
            for _ in range(N // 5):
                e = edges[rng.integers(len(edges))]
                u, v = e
                amount = min(node_wealth[u] * 0.1, 1.0)
                node_wealth[u] -= amount
                node_wealth[v] += amount * (1 - debt_rate)
                hidden_debt[v] += amount * debt_rate

            elastic_tension = np.sum(hidden_debt)
            tension_ratio = elastic_tension / bekenstein_limit

            # If tension exceeds Bekenstein: SNAP-BACK
            if tension_ratio > 1.0 and collapse_step is None:
                collapse_step = t
                # Catastrophic redistribution: debt becomes visible
                node_wealth -= hidden_debt * 0.5
                node_wealth = np.maximum(node_wealth, 0.01)
                hidden_debt *= 0.1  # Most debt crystallizes

            sorted_w = np.sort(node_wealth)
            n = len(sorted_w)
            index = np.arange(1, n + 1)
            gini = (2 * np.sum(index * sorted_w) / (n * np.sum(sorted_w))) - (n + 1) / n
            gini_history.append(gini)
            tension_history.append(tension_ratio)

        results.append({
            'debt_rate': debt_rate,
            'final_gini': gini_history[-1],
            'max_tension': max(tension_history),
            'collapse_step': collapse_step,
            'collapsed': collapse_step is not None,
            'gini_history': gini_history,
            'tension_history': tension_history
        })
        status = f"üíÄ SNAP at t={collapse_step}" if collapse_step else "‚úì STABLE"
        print(f"  Debt {debt_rate*100:5.1f}%: Gini={gini_history[-1]:.3f}  MaxTension={max(tension_history):.2f}  {status}")

    return results

# =============================================================================
# VISUALIZATIONS
# =============================================================================

def plot_all_attacks(r1, r2, r3, r4, r5, filename="stress_test_results.png"):
    print("\n[*] Plotting Stress Test Results...")
    fig, axes = plt.subplots(2, 3, figsize=(20, 12))
    plt.style.use('dark_background')
    fig.patch.set_facecolor('#0a0a0f')

    # Attack 1: Rogue AI
    ax = axes[0, 0]
    ax.set_facecolor('#0a0a0f')
    mults = [r['rogue_mult'] for r in r1]
    damages = [r['damage'] for r in r1]
    colors1 = ['#00FF88' if d < 10 else '#FFD700' if d < 30 else '#FF4444' for d in damages]
    ax.bar(range(len(mults)), damages, color=colors1, edgecolor='white', linewidth=0.5)
    ax.set_xticks(range(len(mults)))
    ax.set_xticklabels([f"{m}x" for m in mults])
    ax.set_xlabel("Rogue Strength")
    ax.set_ylabel("Coherence Damage (%)")
    ax.set_title("ATK 1: ROGUE AI\n(Noosphere Poisoning)", fontweight='bold', color='#FF4444')
    ax.grid(True, color='#222222')

    # Attack 2: Sybil
    ax = axes[0, 1]
    ax.set_facecolor('#0a0a0f')
    fracs = [r['sybil_frac'] * 100 for r in r2]
    infections = [r['infection_rate'] * 100 for r in r2]
    ax.plot(fracs, infections, color='#FF4444', marker='o', linewidth=2.5, markersize=8)
    ax.axhline(y=r2[0]['infection_rate'] * 100, color='gray', linestyle='--', alpha=0.5,
               label=f"Baseline: {r2[0]['infection_rate']*100:.0f}%")
    ax.set_xlabel("Sybil Nodes (%)")
    ax.set_ylabel("Infection Rate (%)")
    ax.set_title("ATK 2: SYBIL ATTACK\n(Fake Gateway Nodes)", fontweight='bold', color='#FF4444')
    ax.legend(fontsize=9)
    ax.grid(True, color='#222222')

    # Attack 3: Cantillon
    ax = axes[0, 2]
    ax.set_facecolor('#0a0a0f')
    leaks = [r['leakage'] * 100 for r in r3]
    workers = [r['worker_energy'] for r in r3]
    cb_shares = [r['cb_share'] for r in r3]
    ax.plot(leaks, workers, color='#44AAFF', marker='s', linewidth=2.5, label='Worker Energy')
    ax2 = ax.twinx()
    ax2.plot(leaks, cb_shares, color='#FF4444', marker='^', linewidth=2, label='CB Share %')
    ax2.set_ylabel("Central Bank Share (%)", color='#FF4444')
    ax.set_xlabel("Leakage Rate (%)")
    ax.set_ylabel("Worker Energy", color='#44AAFF')
    ax.set_title("ATK 3: CANTILLON AMPLIFICATION\n(Fiat Leakage)", fontweight='bold', color='#FF4444')
    ax.grid(True, color='#222222')

    # Attack 4: Human Minority
    ax = axes[1, 0]
    ax.set_facecolor('#0a0a0f')
    ratios_labels = [r['ratio'] for r in r4]
    drifts = [r['human_drift'] for r in r4]
    colors4 = ['#00FF88' if d < 10 else '#FFD700' if d < 30 else '#FF4444' for d in drifts]
    ax.bar(range(len(ratios_labels)), drifts, color=colors4, edgecolor='white', linewidth=0.5)
    ax.set_xticks(range(len(ratios_labels)))
    ax.set_xticklabels(ratios_labels)
    ax.set_xlabel("Human:AI Ratio")
    ax.set_ylabel("Human Œª‚ÇÅ Drift (%)")
    ax.axhline(y=30, color='red', linestyle='--', alpha=0.5, label='Assimilation Threshold')
    ax.set_title("ATK 4: HUMAN MINORITY\n(Assimilation Risk)", fontweight='bold', color='#FF4444')
    ax.legend(fontsize=9)
    ax.grid(True, color='#222222')

    # Attack 5: Dark Matter
    ax = axes[1, 1]
    ax.set_facecolor('#0a0a0f')
    for r in r5:
        label = f"{r['debt_rate']*100:.0f}%"
        color = '#FF4444' if r['collapsed'] else '#00FF88'
        ax.plot(r['tension_history'], alpha=0.6, linewidth=1.5, color=color)
    ax.axhline(y=1.0, color='red', linewidth=2, linestyle='--', label='Bekenstein Limit')
    ax.set_xlabel("Time Steps")
    ax.set_ylabel("Tension (% of Bekenstein)")
    ax.set_title("ATK 5: DARK MATTER SNAP-BACK\n(Hidden Debt)", fontweight='bold', color='#FF4444')
    ax.legend(fontsize=9)
    ax.grid(True, color='#222222')

    # Summary panel
    ax = axes[1, 2]
    ax.set_facecolor('#0a0a0f')
    ax.set_axis_off()
    summary_text = (
        "STRESS TEST SUMMARY\n"
        "=" * 30 + "\n\n"
        f"ATK 1 (Rogue AI): Max Damage = {max(damages):.1f}%\n"
        f"{'VULNERABLE' if max(damages) > 30 else 'RESILIENT'}\n\n"
        f"ATK 2 (Sybil): Max Infection = {max(infections):.1f}%\n"
        f"{'VULNERABLE' if max(infections) > r2[0]['infection_rate']*100 + 20 else 'RESILIENT'}\n\n"
        f"ATK 3 (Cantillon): Collapse at {next((r['leakage']*100 for r in r3 if r['collapsed']), 'Never')}%\n"
        f"{'PHASE TRANSITION FOUND' if any(r['collapsed'] for r in r3) else 'NO COLLAPSE'}\n\n"
        f"ATK 4 (Minority): Max Drift = {max(drifts):.1f}%\n"
        f"{'ASSIMILATION RISK' if max(drifts) > 30 else 'HUMAN PRESERVED'}\n\n"
        f"ATK 5 (Snap-Back): {sum(1 for r in r5 if r['collapsed'])}/{len(r5)} scenarios collapsed\n"
    )
    ax.text(0.05, 0.95, summary_text, transform=ax.transAxes, fontsize=10,
            verticalalignment='top', fontfamily='monospace', color='white',
            bbox=dict(boxstyle='round', facecolor='#1a1a2e', alpha=0.8))

    plt.suptitle("TAMESIS VULNERABILITY STRESS TEST ‚Äî RED TEAM ANALYSIS",
                 fontsize=16, fontweight='bold', color='white')
    plt.tight_layout()
    path = os.path.join(OUTPUT_DIR, filename)
    plt.savefig(path, dpi=150)
    plt.close()
    print(f"    Saved: {path}")

def plot_cantillon_phase_transition(r3, filename="cantillon_phase_transition.png"):
    print("[*] Plotting Cantillon Phase Transition...")
    fig, ax = plt.subplots(figsize=(12, 7))
    plt.style.use('dark_background')
    fig.patch.set_facecolor('#0a0a0f')
    ax.set_facecolor('#0a0a0f')

    leaks = [r['leakage'] * 100 for r in r3]
    workers = [r['worker_energy'] for r in r3]
    ginis = [r['gini'] for r in r3]

    ax.plot(leaks, workers, color='#44AAFF', marker='s', linewidth=2.5, markersize=8, label='Worker Energy')
    ax_gini = ax.twinx()
    ax_gini.plot(leaks, ginis, color='#FFD700', marker='o', linewidth=2, markersize=6, label='Gini')
    ax_gini.set_ylabel("Gini Coefficient", color='#FFD700')

    # Find collapse threshold
    for r in r3:
        if r['collapsed']:
            ax.axvline(x=r['leakage'] * 100, color='red', linewidth=2, linestyle='--',
                       label=f"COLLAPSE at {r['leakage']*100:.0f}%")
            break

    ax.set_xlabel("Fiat Leakage Rate (%)", fontsize=12)
    ax.set_ylabel("Mean Worker Energy", fontsize=12, color='#44AAFF')
    ax.set_title("CANTILLON AMPLIFICATION: PHASE TRANSITION",
                 fontsize=14, fontweight='bold', color='white')
    ax.legend(loc='upper left', fontsize=10)
    ax_gini.legend(loc='upper right', fontsize=10)
    ax.grid(True, color='#222222')

    plt.tight_layout()
    path = os.path.join(OUTPUT_DIR, filename)
    plt.savefig(path, dpi=150)
    plt.close()
    print(f"    Saved: {path}")

# =============================================================================
# MAIN
# =============================================================================

def main():
    print("=" * 60)
    print("  TAMESIS: VULNERABILITY STRESS TEST")
    print("  (Red Team ‚Äî 5 Adversarial Attacks)")
    print("=" * 60)

    r1 = attack_rogue_ai()
    r2 = attack_sybil()
    r3 = attack_cantillon()
    r4 = attack_human_minority()
    r5 = attack_dark_matter()

    # Visualizations
    print("\n--- GENERATING VISUALIZATIONS ---")
    plot_all_attacks(r1, r2, r3, r4, r5)
    plot_cantillon_phase_transition(r3)

    # Meta-analysis
    print(f"\n{'='*60}")
    print(f"  META-ANALYSIS: WHAT BREAKS AND WHAT HOLDS")
    print(f"{'='*60}")

    vulnerabilities = []
    strengths = []

    # Analyze Attack 1
    max_damage = max(r['damage'] for r in r1)
    if max_damage > 30:
        vulnerabilities.append(f"ROGUE AI: {max_damage:.1f}% coherence damage at max strength")
    else:
        strengths.append(f"NOOSPHERE RESILIENT: Max damage only {max_damage:.1f}%")

    # Analyze Attack 2
    baseline_infection = r2[0]['infection_rate'] * 100
    max_infection = max(r['infection_rate'] * 100 for r in r2)
    if max_infection > baseline_infection + 20:
        vulnerabilities.append(f"SYBIL: Infection rises from {baseline_infection:.0f}% to {max_infection:.0f}%")
    else:
        strengths.append(f"GATEWAY IMMUNE TO SYBIL: Max infection {max_infection:.0f}%")

    # Analyze Attack 3
    collapse = next((r for r in r3 if r['collapsed']), None)
    if collapse:
        vulnerabilities.append(f"CANTILLON COLLAPSE at {collapse['leakage']*100:.0f}% leakage")
    else:
        strengths.append("FIAT NO COLLAPSE: System survives even at 95% leakage")

    # Analyze Attack 4
    max_drift = max(r['human_drift'] for r in r4)
    if max_drift > 30:
        vulnerabilities.append(f"HUMAN ASSIMILATION at 1:{next(r['n_ai'] for r in r4 if r['assimilated'])} ratio")
    else:
        strengths.append(f"HUMAN PRESERVED: Max drift only {max_drift:.1f}%")

    # Analyze Attack 5
    collapse_count = sum(1 for r in r5 if r['collapsed'])
    if collapse_count > 0:
        first_collapse = next(r for r in r5 if r['collapsed'])
        vulnerabilities.append(f"DARK MATTER SNAP-BACK at {first_collapse['debt_rate']*100:.0f}% debt rate")
    else:
        strengths.append("DARK MATTER: No snap-back within test range")

    print("\n  VULNERABILITIES FOUND:")
    for v in vulnerabilities:
        print(f"    üî¥ {v}")

    print("\n  STRENGTHS CONFIRMED:")
    for s in strengths:
        print(f"    üü¢ {s}")

    print(f"\n{'='*60}")

if __name__ == "__main__":
    main()
