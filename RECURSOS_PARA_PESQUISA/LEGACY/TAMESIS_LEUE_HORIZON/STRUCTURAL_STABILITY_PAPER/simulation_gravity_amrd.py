
"""
simulation_gravity_amrd.py
--------------------------
Tamesis-Leue Integration Project
Hypothesis 3 Verification: Gravity as AMRD Restoration Force

Hypothesis: 
Gravity is not a fundamental force, but an emergent "Entropic Force" generated by the 
Leue AMRD (Adaptive Damping) mechanism.
The AMRD field alpha(x) activates to suppress volatility from Mass.
This activation creates an energy gradient in the operator space.
F = - grad(E_amrd)
We verify if this emergent force between two masses follows F ~ 1/r^2.

Mechanism:
1. Place two "Masses" (Volatility sources) at distance d.
2. Compute the AMRD field alpha(x) required to stabilize the system (minimize K).
3. Compute the total "Modulation Energy" E_mod = Integral(alpha(x)^2) or similar cost.
4. Vary d and measure Force F = -dE/dd.
5. Check if F ~ 1/d^2.

Author: Antigravity (Agent) for Tamesis Research
"""

import numpy as np
from scipy.ndimage import gaussian_filter
import matplotlib.pyplot as plt

def run_experiment_h3():
    print("=== TAMESIS-LEUE INTEGRATION: EXPERIMENT 03 (Gravity AMRD) ===")
    
    L = 64
    grid_size = (L, L, L) # 3D sufficient
    print(f"Grid: {grid_size}")
    
    # AMRD Logic:
    # alpha(x) ~ 1 / (1 + Volatility(x))
    # Or in Leue paper: Damping factor alpha adapts to local stress.
    # Cost function (Energy) is usually related to the "effort" of damping or the residual stress.
    # Verlinde: S ~ Area. Entropy gradient -> Force.
    # Here: E_sys ~ Integral ( Volatility(x) * (1 - alpha(x)) + Cost(alpha) )
    # Let's assume the vacuum minimizes:
    # E = Integral [ (alpha * V)^2 + beta * (grad alpha)^2 ]
    # This is a Ginzburg-Landau type functional for the damping field.
    # V is the "Volatility" source from Mass (M/r^ something?).
    # Actually, purely local AMRD: alpha(x) is determined by local V(x).
    # But Gravity is non-local?
    # NO: In Verlinde/Leue, non-locality emerges from the SOLVER of the field equation (Poisson).
    # The AMRD field alpha(x) must solve a diffusion/smoothing equation to be stable.
    
    # Simplified Model:
    # The "Volatility Field" V(x) induced by a mass M is V ~ M * delta(x) (Local)
    # But the "Strain" in the vacuum propagates.
    # Let's assume the vacuum behaves like an elastic medium (Leue's LMC).
    # Stress Sigma satisfies Laplacian Sigma = Source. (Poisson)
    # Then Energy = Integral (grad Sigma)^2.
    # If Sigma ~ 1/r, then Energy(d) ~ 1/d. Force ~ 1/d^2.
    # Does Leue's framework imply Poisson propagation?
    # Yes: The ROC operator K involves the Laplacian.
    # To minimize <K>, the system smooths the LMC field.
    
    distances = np.linspace(4, 20, 15)
    energies = []
    
    # Coordinates
    x = np.linspace(-30, 30, L)
    y = np.linspace(-30, 30, L)
    z = np.linspace(-30, 30, L)
    X, Y, Z = np.meshgrid(x, y, z, indexing='ij')
    
    print(f"{'Distance':<10} | {'System Energy':<15} | {'Force Estimate':<15}")
    print("-" * 50)
    
    for d in distances:
        # 1. Sources (Two Masses)
        # Positioned at +/- d/2 on X axis
        pos1 = np.array([-d/2, 0, 0])
        pos2 = np.array([ d/2, 0, 0])
        
        # Volatility Source Field (Masses)
        # We model them as Gaussians
        R1 = np.sqrt((X-pos1[0])**2 + (Y-pos1[1])**2 + (Z-pos1[2])**2)
        R2 = np.sqrt((X-pos2[0])**2 + (Y-pos2[1])**2 + (Z-pos2[2])**2)
        
        Source = np.exp(-R1**2/2.0) + np.exp(-R2**2/2.0)
        
        # 2. Field Response (Poisson Solver)
        # The LMC/AMRD field 'phi' relaxes to minimize stress.
        # Laplacian(phi) = -Source
        # We solve this in Fourier space.
        
        source_hat = np.fft.fftn(Source)
        
        # k^2 grid
        kx = np.fft.fftfreq(L) * 2 * np.pi
        kX, kY, kZ = np.meshgrid(kx, kx, kx, indexing='ij')
        k2 = kX**2 + kY**2 + kZ**2
        k2[0,0,0] = 1e-6 # Avoid singularity at DC
        
        # Phi_hat = Source_hat / k^2
        phi_hat = source_hat / k2
        
        # 3. Energy of the Configuration
        # E = Integral (grad phi)^2  (Field Energy)
        # This is equivalent to Integral (source * phi)
        # Parseval's theorem: Sum |k * phi_hat|^2
        
        energy_spectral = np.sum(k2 * np.abs(phi_hat)**2)
        
        # Real space check (optional, slow)
        # phi = np.fft.ifftn(phi_hat).real
        # E_real = np.sum(phi * Source)
        
        energies.append(energy_spectral)
        
        # Force estimate (Finite Difference)
        force = 0
        if len(energies) > 1:
            de = energies[-1] - energies[-2]
            dd = distances[-1] - distances[-2]
            force = -de / dd
            
        print(f"{d:<10.2f} | {energy_spectral:<15.4e} | {force:<15.4e}")
        
    # Analysis
    d_vals = np.array(distances)
    e_vals = np.array(energies)
    
    # Calculate Forces (centered)
    forces = -np.diff(e_vals) / np.diff(d_vals)
    d_centers = (d_vals[:-1] + d_vals[1:]) / 2
    
    # Start analysis from index 2 to avoid near-field artifacts
    valid_idx = slice(2, None)
    d_fit = d_centers[valid_idx]
    f_fit = forces[valid_idx]
    
    # Fit: Log(F) = n * Log(d) + C
    # We expect n = -2 for Newton
    log_d = np.log(d_fit)
    log_f = np.log(f_fit)
    
    slope, intercept = np.polyfit(log_d, log_f, 1)
    
    print("\n--- RESULTS H3 ---")
    print(f"Force Scaling Exponent: {slope:.4f}")
    
    if -2.2 <= slope <= -1.8:
        print("[SUCCESS] H3 CONFIRMED: Emergent Force follows Inverse Square Law (Newtonian).")
    else:
        print(f"[FAILURE] H3 Refuted. Scaling is {slope:.2f}")

    # Plot
    plt.figure(figsize=(10,6))
    plt.loglog(d_fit, f_fit, 'o-', label=f'Simulated Force (slope={slope:.2f})')
    # Reference lines
    ref_d = np.linspace(d_fit.min(), d_fit.max(), 100)
    plt.loglog(ref_d, f_fit[0] * (d_fit[0]/ref_d)**2, '--', label='1/r^2 (Newton)')
    plt.loglog(ref_d, f_fit[0] * (d_fit[0]/ref_d)**1, ':', label='1/r (Cylindrical)')
    plt.loglog(ref_d, f_fit[0] * (d_fit[0]/ref_d)**3, '-.', label='1/r^3 (Dipole)')
    
    plt.xlabel('Distance (r)')
    plt.ylabel('Force (F)')
    plt.title('H3: Emergent Gravity Validation')
    plt.legend()
    plt.grid(True, which="both", ls="-")
    plt.savefig('h3_gravity_newton.png')

if __name__ == "__main__":
    run_experiment_h3()
